[
  {
    "id": 1,
    "question": "1. 다음 중 명령어 튜닝 LLM(Instruction-Tuned LLMs)에 대한 설명으로 올바른 것은?",
    "options": {
      "A": "LLM의 추론, 의사결정 및 메모리를 통합하고 도구를 사용해 작업을 자동으로 수행하는 \n애플리케이션",
      "B": "학습된 언어 패턴을 기반으로 다음 단어를 예측할 수 있는 다양한 텍스트 데이터로 사전 학습된 \n범용 모델",
      "C": "종종 피드백을 통해 올바른 답변을 유도하는 명령을 따르도록 훈련된 LLM",
      "D": "LLM 기능과 검색 도구를 결합해 정확하고 맥락적으로 적절한 응답을 생성하는 기술"
    },
    "answer": "C",
    "points": 1
  },
  {
    "id": 2,
    "question": "2. 다음 중 딥러닝(Deep Learning)의 특징이 아닌 것은 무엇인가?",
    "options": {
      "A": "신경망(Neural Networks)을 사용해 데이터에서 자동으로 특징을 학습한다.",
      "B": "사용자가 수동으로 특징을 정의해야 한다.",
      "C": "이미지 및 텍스트 코퍼스(text corpus)와 같은 크고 복잡한 데이터셋을 처리할 수 있다.",
      "D": "수동적인 특징 선택이 필요하지 않다."
    },
    "answer": "B",
    "points": 1
  },
  {
    "id": 3,
    "question": "3. 다음 중 대형 언어 모델(LLM)에서 토큰화(Tokenization)의 첫 번째 단계에 대한 가장 적절한 설명은?",
    "options": {
      "A": "토큰을 고차원 벡터로 변환해 의미를 포착한다.",
      "B": "텍스트를 문자, 단어 전체 또는 단어의 일부와 같은 더 작은 단위로 나눈다.",
      "C": "신경망을 이용해 맥락에 맞는 적절한 응답을 생성한다.",
      "D": "학습된 관계를 기반으로 시퀀스에서 다음 토큰을 예측한다."
    },
    "answer": "B",
    "points": 1
  },
  {
    "id": 4,
    "question": "4. 다음 중 맥락 창(context window)에 대한 설명으로 가장 적절한 것은 무엇인가?",
    "options": {
      "A": "모델이 응답을 생성할 때 고려할 수 있는 이전 텍스트의 양을 의미하며, 토큰 단위로 측정된다.",
      "B": "모델의 학습 파라미터 수를 조절하여 성능을 향상시키는 방법이다.",
      "C": "멀티모달 데이터를 처리하기 위해 이미지나 오디오 데이터를 텍스트로 변환하는 과정이다",
      "D": "모델이 토큰 간의 의미적 관계를 포착하기 위해 사용하는 벡터 공간이다."
    },
    "answer": "A",
    "points": 1
  },
  {
    "id": 5,
    "question": "5. 다음 대형 언어 모델(LLM) 유형(1-4)과 그에 대한 설명(A-D)을 가장 적절히 연결 지은 것은?",
    "question_type": "matching",
    "prompt": {
      "1": "파운데이션 모델 (Foundation Model)",
      "2": "명령어 튜닝 모델 (Instruction-Tuned Model)",
      "3": "추론 모델 (Reasoning Model)",
      "4": "비전-언어 모델 (Vision-Language Model)"
    },
    "options": {
      "A": "1D, 2B, 3A, 4C",
      "B": "1C, 2B, 3D, 4A",
      "C": "1D, 2C, 3B, 4A",
      "D": "1B, 2D, 3A, 4C"
    },
    "answer": "A",
    "points": 1
  },
  {
    "id": 6,
    "question": "6. 다음 중 파운데이션 모델(Foundation Model), 명령어 튜닝 모델(Instruction-tuned Model), 추론 \n모델(Reasoning Model)의 특징과 해당 모델의 활용에 대한 설명으로 옳지 않은 것은 무엇인가? ",
    "options": {
      "A": "파운데이션 모델은 방대한 데이터셋으로 훈련되며, 파인튜닝(fine-tuning)을 통해 특정 작업에 \n맞게 조정될 수 있다.",
      "B": "추론 모델은 명령어 튜닝 모델 기반으로 복잡한 추론 능력을 향상시켜, 연쇄적 사고(chain-of\nthought reasoning)를 수행할 수 있다.",
      "C": "소프트웨어 테스팅에서 파운데이션 모델은 다양한 도메인에서의 작업 수행을 위한 기반으로 \n활용될 수 있다. ",
      "D": "명령어 튜닝 모델은 사용자 지시에 반응하도록 최적화되어 있으며, 파인튜닝 없이도 특정 작업에 \n최적화되어 있다"
    },
    "answer": "D",
    "points": 1
  },
  {
    "id": 7,
    "question": "7. 다음 중 멀티모달 LLM(Multimodal LLMs)과 비전-언어 모델(Vision-Language Models)의 관계를 가장 잘 \n설명하는 것은?",
    "options": {
      "A": "멀티모달 LLMs는 다양한 입력을 처리하도록 설계된 비전-언어 모델의 하위 집합이다.",
      "B": "비전-언어 모델은 시각 및 텍스트 데이터를 처리하는 멀티모달 LLMs의 하위 집합이다.",
      "C": "비전-언어 모델은 멀티모달 LLMs과 관련이 없으며 GUI만 처리한다.",
      "D": "멀티모달 LLMs과 비전-언어 모델은 서로 교체해서 사용할 수 있는 용어이다."
    },
    "answer": "B",
    "points": 1
  },
  {
    "id": 8,
    "question": "8. 멀티모달 LLM에서 이미지를 임베딩(embedding)으로 변환하는 주된 이유로 가장 적절한 것은 무엇인가?",
    "options": {
      "A": "이미지를 픽셀 단위로 분해하여 텍스트 토큰(token)과 동일한 방식으로 처리하기 위해서",
      "B": "이미지 데이터를 수치 벡터로 표현하여 트랜스포머(Transformer) 모델이 이해할 수 있도록 하기 \n위해서",
      "C": "이미지와 텍스트 간의 연관성을 제거하여 모델의 복잡도를 낮추기 위해서",
      "D": "이미지 데이터를 비전-언어 모델에서 직접 처리하지 못하기 때문에 텍스트로 변환하기 위해서"
    },
    "answer": "B",
    "points": 1
  },
  {
    "id": 9,
    "question": "9. 다음 중 소프트웨어 테스팅 과업에서 가장 중요한 LLM 기능 두 가지는 무엇인가? (두 개 선택)",
    "options": {
      "A": "요구사항을 분석해 모호성과 불일치를 식별하는 기능",
      "B": "배포를 위한 완전한 애플리케이션 코드를 생성하는 기능",
      "C": "모든 테스트 스크립트를 인간의 개입 없이 자동화하는 기능",
      "D": "애플리케이션에서 수동으로 탐색적 테스팅을 수행하는 기능 \nE. \n다양한 조합과 범위로 테스트 데이터를 생성하는 기능",
      "E": "다양한 조합과 범위로 테스트 데이터를 생성하는 기능 "
    },
    "answer": "A,E",
    "question_type": "multiple",
    "points": 1
  },
  {
    "id": 10,
    "question": "10. 다음 중 LLM(Large Language Model)이 소프트웨어 테스팅 과정에서 수행할 수 있는 가장 적절한 \n기능은 무엇인가?",
    "options": {
      "A": "테스트 실행(test execution) 및 결과 판정(test result determination) 자동화",
      "B": "테스트 환경(test environment) 구성 및 관리",
      "C": "결함(defect) 수정 및 코드 변경",
      "D": "테스트 계획(test plan) 및 보고서(report) 자동 생성"
    },
    "answer": "D",
    "points": 1
  },
  {
    "id": 11,
    "question": "11. 다음 중 AI 챗봇과 LLM 기반 테스팅 애플리케이션의 차이점을 가장 적절히 요약한 것은?",
    "options": {
      "A": "AI 챗봇은 특정 테스팅 작업에 더 적합한 반면, LLM-기반 테스팅 애플리케이션은 즉흥적 \n상호작용(ad hoc interactions)에 초점을 맞춘다.",
      "B": "AI 챗봇과 LLM 기반 테스팅 애플리케이션은 동일한 작업을 수행하도록 설계되었으며, 설정 \n차이가 없다.",
      "C": "LLM 기반 테스팅 애플리케이션은 대화형 프롬프트를 사용하는 반면, AI 챗봇은 테스트 도구 및 \n워크플로우에 통합되어야 한다.",
      "D": "AI 챗봇은 즉흥적 테스팅 작업을 위한 대화형 인터페이스를 제공하는 반면, LLM 기반 테스팅 \n애플리케이션은 특정 작업을 위한 맞춤형 솔루션을 제공한다."
    },
    "answer": "D",
    "points": 1
  },
  {
    "id": 12,
    "question": "12. AI 챗봇을 사용하여 테스터가 캐스케이딩 프롬프트(cascading prompts)를 활용할 때 얻을 수 있는 \n이점으로 가장 적절한 것은 무엇인가?",
    "options": {
      "A": "초기 요청만으로 모든 정보를 완벽히 얻을 수 있다.",
      "B": "추가 질문을 통해 원하는 결과를 점진적으로 구체화하고 개선할 수 있다.",
      "C": "프롬프트 없이도 AI가 자동으로 필요한 테스트 케이스를 생성한다.",
      "D": "테스터의 개입 없이 AI가 모든 테스팅 작업을 수행한다."
    },
    "answer": "B",
    "points": 1
  },
  {
    "id": 13,
    "question": "13. 다음 중 LLM에서 \"프롬프트 엔지니어링(prompt engineering)\"의 가장 적절한 정의는 무엇인가?",
    "options": {
      "A": "소프트웨어 테스팅 워크플로우를 자동화하는 과정",
      "B": "원하는 출력을 생성하도록 LLM의 입력 프롬프트를 설계하고 개선하는 과정",
      "C": "대량의 데이터셋을 사용해 LLM을 훈련시키는 방법",
      "D": "기존 테스팅 프레임워크에 LLM을 통합하는 작업"
    },
    "answer": "B",
    "points": 1
  },
  {
    "id": 14,
    "question": "14. 다음 중 구조화된 프롬프트(Structured Prompt)의 컴포넌트와 이의 소프트웨어 테스팅 작업에 대한 \n기여도를 가장 잘 설명하고 있는 것은?",
    "options": {
      "A": "구조화된 프롬프트는 입력 데이터와 출력 형식에만 집중함으로써, 테스팅 작업을 위한 정밀한 \n생성형 AI(GenAI) 응답을 보장한다.",
      "B": "구조화된 프롬프트의 효과는 주로 제약 사항(constraints)을 제공하는 데 있으며, 이는 입력 \n데이터가 처리되는 방식을 결정한다.",
      "C": "구조화된 프롬프트에는 역할, 맥락, 지침, 입력 데이터, 제약 사항, 출력 형식이 포함되어 LLM의 \n출력을 테스팅 작업 목표에 맞춘다.",
      "D": "구조화된 프롬프트는 명확한 지침의 우선순위를 지정해, LLM을 가이드하는 데 있어 역할과 \n맥락을 선택 사항으로 만든다."
    },
    "answer": "C",
    "points": 1
  },
  {
    "id": 15,
    "question": "15. 다음 중 프롬프트의 구성 요소와 그에 대한 설명이 올바르게 짝지어진 것은 무엇인가?",
    "options": {
      "A": "맥락(Context) - LLM이 출력할 응답의 형식을 지정한다.",
      "B": "출력 형식(Output Format) - LLM이 응답을 생성할 때 참고하는 배경 정보를 제공한다.",
      "C": "제약 사항(Constraints) - LLM이 따라야 할 제한 사항이나 특별한 고려 사항을 명시한다.",
      "D": "지침(Instruction) - LLM 이 사용할 데이터나 아티팩트를 제공한다."
    },
    "answer": "C",
    "points": 1
  },
  {
    "id": 16,
    "question": "16. 다음 중 프롬프트 체이닝(Prompt Chaining), 퓨샷 프롬프팅(Few-Shot Prompting), 메타 프롬프팅(Meta \nPrompting) 기법의 차이점을 가장 잘 설명하고 있는 것은?",
    "options": {
      "A": "프롬프트 체이닝은 예시를 제공하는데 집중하고, 퓨샷 프롬프팅은 작업을 하위작업으로 나누며, \n메타 프롬프팅은 프롬프트를 수동으로 개선하는 방식이다.",
      "B": "퓨샷 프롬프팅은 예제를 통해 LLM을 안내하고, 프롬프트 체이닝은 작업을 중간 단계로 나누며, \n메타 프롬프팅은 모델이 자체 프롬프트를 반복적으로 개선하도록 하는 방식이다.",
      "C": "메타 프롬프팅은 작업을 단계별로 세분화하는 것을 강조하고, 프롬프트 체이닝은 예제를 \n활용하며, 퓨샷 프롬프팅은 프롬프트를 수동으로 최적화하는 방식이다.",
      "D": "프롬프트 체이닝은 예제 없이 작동하고, 퓨샷 프롬프팅은 예제를 제공하며, 메타 프롬프팅은 \n테스터가 정의한 프롬프트에 의존한다."
    },
    "answer": "B",
    "points": 1
  },
  {
    "id": 17,
    "question": "17. 다음 중 프롬프트 체이닝(Prompt Chaining)과 연쇄적 사고 프롬프팅(Chain-of-thought Prompting)의 \n차이점으로 올바른 것은 무엇인가?",
    "options": {
      "A": "둘 다 작업을 하위 작업으로 분해하지만, 프롬프트 체이닝은 LLM이 이를 자동으로 수행한다.",
      "B": "두 기법은 동일하며 차이점이 없다.",
      "C": "프롬프트 체이닝은 예시를 제공하고, 연쇄적 사고 프롬프팅은 메타 프롬프팅의 일종이다.",
      "D": "프롬프트 체이닝은 사용자가 작업을 하위 단계로 나누고, 연쇄적 사고 프롬프팅은 LLM이 스스로 \n작업을 분해한다."
    },
    "answer": "D",
    "points": 1
  },
  {
    "id": 18,
    "question": "18. 다음은 소프트웨어 테스팅에 다양한 프롬프팅 기법을 결합하여 활용하는 예시이다.  \n다음 중 잘못된 것은?",
    "options": {
      "A": "복잡한 테스트를 위해 프롬프트 체이닝을 적용하여 과정을 단계별로 분리한다.",
      "B": "각 단계에서 원하는 결과에 대한 예시를 제공하여 퓨샷 프롬프팅을 활용한다.",
      "C": "AI에게 각 단계에서 필요한 추가 정보를 요청하거나 프롬프트를 개선하도록 유도하여 메타 \n프롬프팅을 활용한다.",
      "D": "제로샷 프롬프팅을 활용하여 프롬프트 설계에 필요한 수동 노력을 최소화한다."
    },
    "answer": "D",
    "points": 1
  },
  {
    "id": 19,
    "question": "19. 다음 각각의 테스팅 시나리오에 대해 가장 적절한 프롬프팅 기법을 선택해야 한다.   \n시나리오 1: \n복잡한 테스팅 작업을 분석해야 하며, 테스트 설계를 여러 단계로 나누어 각 단계의 정확성을 검증\n한 후 다음 단계로 진행해야 한다. \n시나리오 2: \n반복적인 시나리오 기반 테스팅 작업을 위해 Gherkin 스타일 테스트 케이스를 생성해야 한다. 출력\n은 특정 형식을 따라야 한다. \n시나리오 3: \n탐색적 테스팅 및 결함 분석에서 얻은 인사이트를 포함하는 동적이고 유연한 테스트 보고서를 준비\n해야 한다. 보고서는 이해관계자의 요구에 맞춰 조정될 수 있어야 한다. \n다음 중 프롬프팅 기법을 올바르게 할당한 옵션은 무엇인가?",
    "options": {
      "A": "프롬프트 체이닝 → 시나리오 1, 퓨샷 프롬프팅 → 시나리오 2, 메타 프롬프팅 → 시나리오 3",
      "B": "퓨샷 프롬프팅 → 시나리오 1, 프롬프트 체이닝 → 시나리오 2, 메타 프롬프팅 → 시나리오 3",
      "C": "메타 프롬프팅 → 시나리오 1, 퓨샷 프롬프팅 → 시나리오 2, 프롬프트 체이닝 → 시나리오 3",
      "D": "퓨샷 프롬프팅 → 시나리오 1, 메타 프롬프팅 → 시나리오 2, 프롬프트 체이닝 → 시나리오 3"
    },
    "answer": "A",
    "points": 2
  },
  {
    "id": 20,
    "question": "20. 테스터가 AI를 활용하여 복잡한 시스템의 테스트 케이스를 생성하려고 합니다. 그는 새로운 작업에 대한 \nAI의 맥락 이해를 돕기 위해 상위레벨의 지침을 제공하고, 동시에 출력 형식을 일관되게 유지하기 위해 \n예시를 제공하고자 합니다.  \n이 경우 가장 적절한 프롬프트 기법의 조합은 무엇인가?",
    "options": {
      "A": "메타 프롬프팅(Meta Prompting)과 퀵샷 프롬프팅(Quick-shot Prompting)",
      "B": "프롬프트 체이닝(Prompt Chaining)과 퓨샷 프롬프팅(Few-shot Prompting)",
      "C": "메타 프롬프팅(Meta Prompting)과 퓨샷 프롬프팅(Few-shot Prompting)",
      "D": "프롬프트 체이닝(Prompt Chaining)과 제로샷 프롬프팅(Zero-shot Prompting)"
    },
    "answer": "C",
    "points": 1
  },
  {
    "id": 21,
    "question": "21. 다음 중 메타 프롬프팅(Meta Prompting) 기법을 활용해야 하는 테스트 작업으로 가장 적절한 것은 \n무엇인가?",
    "options": {
      "A": "테스트 케이스의 출력 형식을 일관되게 유지하며 반복적인 테스트 케이스를 생성하는 작업",
      "B": "작업을 단계별로 분해하여 각 단계의 결과를 검증하는 작업",
      "C": "새로운 탐색적 테스팅을 수행하며 AI에게 상위레벨의 지침을 제공해야 하는 작업",
      "D": "테스트 자동화를 위해 키워드 주도 테스트를 생성하는 작업"
    },
    "answer": "C",
    "points": 1
  },
  {
    "id": 22,
    "question": "22. LLM과의 상호작용에서 시스템 프롬 프트(system prompt)의 주요 기능은 무엇인가?",
    "options": {
      "A": "전체 대화 동안 LLM 행동에 대한 프레임워크를 제공한다.",
      "B": "사용자가 GenAI에게 요청하는 특정 문제 또는 지시사항을 제공한다.",
      "C": "각 사용자 상호작용에 맞춰 동적으로 조정하고 대화의 맥락을 설정한다.",
      "D": "사용자로부터 보여지는 입력을 받아 대화의 규칙을 설정한다."
    },
    "answer": "A",
    "points": 1
  },
  {
    "id": 23,
    "question": "23. 다음 중 시스템 프롬프트(System Prompt)를 효과적으로 구현하기 위한 방법으로 옳은 것은 어떤 것인가?",
    "options": {
      "A": "시스템 프롬프트는 가능한 한 모호하게 작성하여 LLM이 유연하게 동작하도록 한다.",
      "B": "시스템 프롬프트는 사용자에게 직접 보여주어 사용자와 상호작용하도록 한다.",
      "C": "시스템 프롬프트에서 LLM의 역할과 제한 사항에 대해 명확하고 구체적으로 정의한다.",
      "D": "시스템 프롬프트는 각 상호작용마다 변경되도록 하여 다양한 응답을 유도한다."
    },
    "answer": "C",
    "points": 1
  },
  {
    "id": 24,
    "question": "24. 다음 중 시스템 프롬프트(system prompt)와 사용자 프롬프트(user prompt)의 차이점에 대한 설명으로 \n가장 부적절한 것은?",
    "options": {
      "A": "시스템 프롬프트는 LLM의 기본적인 동작 방식, 성격, 운영 파라미터를 정의하는 기본적인 명령 \n집합이며, 사용자 프롬프트는 사용자가 입력하는 실제 입력 또는 질문이다.",
      "B": "시스템 프롬프트는 상호작용 세션 내내 변하지 않고 지속되는 반면, 사용자 프롬프트는 각 \n상호작용마다 변경된다.",
      "C": "시스템 프롬프트는 LLM이 어떻게 응답해야 하는지에 대한 구체적인 지침을 제공하며, 사용자 \n프롬프트는 LLM에게 특정 지침, 질문 또는 작업을 요청한다.",
      "D": "시스템 프롬프트는 일반적으로 최종 사용자에게 숨겨져 있으며, 사용자 프롬프트는 사용자에게 \n직접적으로 보인다."
    },
    "answer": "C",
    "points": 1
  },
  {
    "id": 25,
    "question": "25. 새 프로젝트를 위한 요구사항과 사용자 스토리 분석을 위해 생성형 AI를 활용하는 작업을 맡았다. 목표는 \n테스트 컨디션을 생성하고, 리스크를 기반으로 우선순위를 정하며, 잠재적인 커버리지 갭(coverage \ngaps)을 식별하는 것이다.   \n이 프로세스에서 포괄적이면서 우선순위화된 결과물을 얻기 위해 프롬프트 체이닝(prompt chaining) \n기법을 사용해 생성형 AI를 효과적으로 활용하려면 다음 중 어떤 단계를 수행해야 하는가?  (2점)",
    "question_type": "matching",
    "prompt": {
      "i": "요구사항과 사용자 스토리를 입력하고 LLM에 제공된 정보를 기반으로 테스트 컨디션을 생성하도록 프롬프트 한다.",
      "ii": "프로젝트 목표에 따라 우선순위가 지정된 테스트 컨디션을 생성하도록 상세한 인수 조건을 제공해 LLM이 맥락을 이해하도록 한다.",
      "iii": "GenAI가 커버리지 분석을 수행하도록 명시적으로 지시해 요구사항의 모든 측면이 테스트 컨디션에서 다뤄지도록 한다.",
      "iv": "최소한의 입력을 사용하고 GenAI가 일반 지식을 기반으로 자동으로 커버리지 갭을 추론하도록 한다.",
      "v": "요구사항과 사용자 스토리에서 불일치 및 모호성을 분석해 테스트 기반 자료(테스트 베이스)의 잠재적 결함을 식별하도록 LLM에 요청한다."
    },
    "options": {
      "A": "i, ii, iii",
      "B": "ii, iii, iv",
      "C": "i, ii, v",
      "D": "iii, iv, v"
    },
    "answer": "A",
    "points": 1
  },
  {
    "id": 26,
    "question": "26. 생성형 AI를 활용하여 위험에 기반한 테스트 컨디션 우선순위를 설정 할 때 고려해야 할 요소로 가장 \n옳지 않은 것은 무엇인가?",
    "options": {
      "A": "기능의 사용자 노출 정도",
      "B": "규제 준수 여부",
      "C": "개발자의 개발 능력 수준",
      "D": "과거 결함 데이터 "
    },
    "answer": "C",
    "points": 1
  },
  {
    "id": 27,
    "question": "27. 자동차 제조 회사에서 자율 주행 차량의 차선 인식 시스템을 개발 중이다. 이 시스템은 카메라와 센서를 \n활용하여 도로의 차선을 인식하고 차량을 제어한다. 테스터는 생성형 AI를 활용하여 테스트 기법을 \n제안받고자 한다. \n주어진 상황은 아래와 같다. \n- \n시스템은 다양한 기상 조건, 도로 상태, 차선 표시 유형을 처리해야 한다. \n- \n안전이 최우선이며, 결함이 발생하면 심각한 결과를 초래할 수 있다. \n테스터는 생성형 AI에게 어떤 입력 데이터와 지침을 제공해야 적절한 테스트 기법을 제안 받을 수 \n있는가?",
    "options": {
      "A": "시스템의 요구사항 명세서, 다양한 기상 조건과 도로 상태에 대한 시나리오, 과거 결함 사례를 \n제공하고, 안전 중요 시스템에 적합한 테스트 기법을 제안하도록 요청한다.",
      "B": "시스템의 요구사항 명세서와 차선 표시 유형의 이미지 데이터를 제공하고, 이미지 인식 정확성을 \n높이는 테스트 기법을 제안하도록 요청한다.",
      "C": "시스템의 아키텍처 다이어그램과 성능 요구사항을 제공하고, 성능 테스트 기법을 중점적으로 \n제안하도록 요청한다.",
      "D": "기상 조건과 도로 상태의 시나리오와 사용자 경험 보고서를 제공하고, 사용자 만족도를 \n향상시키는 테스트 기법을 제안하도록 요청한다."
    },
    "answer": "A",
    "points": 2
  },
  {
    "id": 28,
    "question": "28. 다음 사용자 스토리와 테스트 컨디션을 바탕으로 Gherkin 스타일의 테스트 시나리오를 생성하기 위해 \n퓨샷 프롬프팅(few-shot prompting) 기법을 적용하는 작업을 맡았다. \n사용자 스토리: \"사용자로서 비밀번호를 잊어버렸을 때 계정에 재접근하기 위해 비밀번호를 재설\n정하고 싶다.\" \n테스트 컨디션: \"사용자가 등록된 이메일 주소를 제공하면 비밀번호 재설정 안내 이메일을 받는지 \n확인한다.\" \n이전에 정의된 사용자 스토리, 테스트 컨디션, Gherkin 스타일 테스트 시나리오의 예시가 있다.   \n다음 중 위의 사용자 스토리와 테스트 컨디션에 정확하게 부합하는 테스트 시나리오 생성을 위한 최적의 \n프롬프트는 무엇인가?",
    "options": {
      "A": "프롬프트 A \n역할: 테스트 설계자 \n맥락: 비밀번호 재설정 기능을 테스트하고 있다. \n지침: 사용자 스토리와 테스트 컨디션을 위한 Gherkin 스타일 테스트 시나리오를 생성한다. 출력 \n결과가 빠짐없이 포함되도록 한다. \n입력 데이터: <<<사용자 스토리>>> 및 <<<테스트 컨디션>>> \n제약 사항: \"Given-When-Then\" 구문을 사용하며 테스트 컨디션의 높은 커버리지를 목표로 한다. \n출력 형식: 다수의 Gherkin 스타일 테스트 시나리오를 제공한다.",
      "B": "프롬프트 B \n역할: Gherkin 기반 시나리오 전문 테스트 설계자 \n맥락: 비밀번호 재설정 기능을 테스트하고 있다. \n지침: 이전에 정의된 예시를 참고해 사용자 스토리와 테스트 컨디션을 위한 Gherkin 스타일 \n테스트 시나리오를 생성한다. \n입력 데이터: <<<사용자 스토리>>> 및 <<<테스트 컨디션>>> \n제약 사항: \"Given-When-Then\" 구문을 사용하고 테스트 컨디션과 일치하는지 확인한다. \n출력 형식: 주어진 Gherkin 스타일 테스트 시나리오를 준수한다.",
      "C": "프롬프트 C \n역할: 테스트 설계자 \n맥락: 비밀번호 재설정 기능을 테스트하고 있다. \n지침: 베스트 프랙티스를 사용해 사용자 스토리와 테스트 컨디션을 위한 Gherkin 스타일 테스트 \n시나리오를 생성한다. \n입력 데이터: <<<사용자 스토리>>> 및 <<<테스트 컨디션>>> \n제약 사항: \"Given-When-Then\" 구문을 따르며 테스트 컨디션을 커버한다. \n출력 형식: 예상 출력이 포함된 테스트 케이스를 생성한다. ",
      "D": "프롬프트 D \n역할: 테스트 설계자 \n맥락: 비밀번호 재설정 기능을 테스트하고 있다. \n지침: 사용자 스토리와 테스트 컨디션을 위한 최소 두 개의 Gherkin 스타일 테스트 시나리오를 생성하고 엣지 케\n이스(edge cases)에 집중한다. \n입력 데이터: <<<사용자 스토리>>> 및 <<<테스트 컨디션>>> \n제약 사항: 모든 시나리오는 \"Given-When-Then\" 구문을 준수한다. \n출력 형식: 다수의 Gherkin 스타일 테스트 시나리오를 제공한다."
    },
    "answer": "B",
    "points": 2
  },
  {
    "id": 29,
    "question": "29. 한 금융 기관에서 새로운 온라인 뱅킹 시스템을 개발하고 있다. 이 시스템은 고객들이 계좌 조회, 송금, \n투자 등을 할 수 있게 해준다. 보안과 정확성이 최우선이며, 금융 관련 법규를 준수해야 한다. \n테스트 목표는 아래와 같다. - - \n생성형 AI를 활용하여 테스트 케이스를 생성한다. \n다양한 사용자 시나리오를 포함한다. \n테스터가 생성형 AI에게 어떤 입력 데이터와 지침을 제공해야 가장 포괄적이고 정확한 테스트 케이스를 \n얻을 수 있는가?  (1점) ",
    "options": {
      "A": "시스템의 기능 요구사항, 보안 정책, 사용자 유형별 시나리오를 제공하고, 각 기능에 대한 테스트 \n케이스 생성을 요청한다.",
      "B": "시스템의 아키텍처 다이어그램과 보안정책, 사용자 시나리오를 제공하고, 테스트 케이스 생성을 \n요청한다.",
      "C": "경쟁사의 온라인 뱅킹 시스템 매뉴얼, 보안 정책, 사용자 시나리오를 제공하고, 이를 기반으로 \n테스트 케이스 생성을 요청한다.",
      "D": "개발 팀의 재사용을 위한 소스 코드(스니펫), 보안 정책, 사용자 시나리오를 제공하고, 코드 \n리뷰를 통한 테스트 케이스 생성을 요청한다."
    },
    "answer": "A",
    "points": 1
  },

  {
    "id": 30,
    "question": "30. 생성형 AI를 활용하여 테스트 케이스를 생성할 때 가장 중요한 입력 데이터로 가장 알맞은 것은 \n무엇인가?",
    "options": {
      "A": "소프트웨어의 소스 코드 전체",
      "B": "경쟁사의 제품 매뉴얼",
      "C": "기능적 요구사항과 비즈니스 룰",
      "D": "테스트 계획"
    },
    "answer": "C",
    "points": 1
  },
  {
    "id": 31,
    "question": "31. 리그레션 테스트 실행 보고서를 분석하기 위한 구조화된 프롬프트 엔지니어링(structured prompt \nengineering)을 적용하는 작업을 맡았다. 다음은 초기 프롬프트 초안이다:   \n역할: 테스트 분석가 \n맥락: 최근 실행된 리그레션 테스트 결과의 원시(raw) 데이터를 분석한다. \n지침: 테스트 결과에서 불일치를 식별한다. \n입력 데이터: 첨부된 원시 테스트 실행 결과를 사용한다. \n제약 사항: 교차 확인을 위해 알려진 이상현상 목록(anomalies list)을 사용한다. \n출력 형식: 불일치 목록을 표 형태로 제공한다. \n위 프롬프트를 개선해야 할 때, 다음 중 포괄적인 리그레션 테스트 보고서 분석을 위한 구조화된 \n프롬프트 엔지니어링 베스트 프랙티스(best practice)에 가장 부합하는 개선 방안은 무엇인가?",
    "options": {
      "A": "유사한 문제들을 그룹화하고, 결과를 이상현상 목록과 교차 검토하는 단계를 추가한다.",
      "B": "역할을 실행 가능한 개선점 도출을 전문으로 하는 리그레션 테스트 분석가로 구체화한다.",
      "C": "지침을 확장해 예상 결과와 실제 결과를 분리하고, 유사한 문제를 구룹화하고, 불일치를 강조 \n한다.",
      "D": "제약 사항에 Given-When-Then 등과 같은 리그레션 테스팅 원칙에 대한 참조를 포함한다."
    },
    "answer": "C",
    "points": 2
  },
  {
    "id": 32,
    "question": "32. GUI(Graphical User Interface) 리그레션 테스트에서 생성형 AI(Generative AI)의 적용 사례로 가장 \n적절한 것은 무엇인가?",
    "options": {
      "A": "사용자의 행동 패턴을 예측하여 UI 디자인을 자동으로 개선한다.",
      "B": "UI의 리그레션 테스트를 토대로 새로운 UI 요소를 자동으로 생성하여 UI에 반영될 수 있도록 \n개발자에게 제안한다.",
      "C": "리그레션 테스트 수행 시 사용자 인터페이스의 미세한 변화를 감지하여, 영향을 받는 테스트 \n스크립트를 비활성화한다.",
      "D": "UI 변경으로 인해 실패한 테스트 스크립트를 생성형 AI가 자동으로 적응시켜 동적 \n로케이터(dynamic locator)와 수정된 인터랙션을 처리한다."
    },
    "answer": "D",
    "points": 1
  },
  {
    "id": 33,
    "question": "33. API(Application Programming Interface) 리그레션 테스트에서 생성형 AI(Generative AI)가 도전 과제를 \n극복하기 위해 제공할 수 있는 해결책으로 가장 적절한 것은 무엇인가?",
    "options": {
      "A": "API 요청/응답 형식 변경 시, 생성형 AI가 자동으로 스크립트를 수정하여 새로운 사양에 \n적응시킨다",
      "B": "API의 성능 병목 현상을 발견하여 자동으로 코드 최적화를 수행한다.",
      "C": "새로운 API 엔드포인트(endpoint)를 생성하고 보안을 강화한다.",
      "D": "API 테스트를 신속하게 수행한 후 GUI 테스트에 집중하도록 권장한다."
    },
    "answer": "A",
    "points": 1
  },
  {
    "id": 34,
    "question": "34. 테스트 진행 상황, 결함 추이, 커버리지 인사이트와 같은 실행 가능한 테스트 메트릭을 생성하기 위해 \nLLM을 활용하고 있다. 메트릭은 자연어 요약 형태로 대시보드에 표시된다. 목표는 생성된 메트릭이 \n정확하고 실행 가능하며 이해 관계자가 쉽게 해석할 수 있도록 프로세스를 개선하는 것이다.  \nGenAI에게 주는 프롬프트 초안은 다음과 같다:  \n역할: 테스트 메트릭 분석가 \n맥락: 테스팅 도구에서 제공된 원시 테스트 데이터를 분석한다. \n지침: 테스트 진행 상황, 결함 추이, 커버리지 인사이트를 생성한다. \n입력 데이터: 테스팅 도구에서 추출한 원시 데이터를 제공한다. \n제약 사항: 출력이 간결하고 이해하기 쉬워야 한다. \n출력 형식: 메트릭을 대시보드에 표시한다. \n이 프롬프트를 개선할 때, 다음 중 GenAI가 정확하고 실행 가능한 메트릭을 생성하도록 LLM의 능력을 \n향상시킬 가장 최적화된 개선 사항은 무엇인가?",
    "options": {
      "A": "역할을 의사결정 지원과 실질적 개선점 도출을 전문으로 하는 테스트 메트릭 분석가로 지정한다.",
      "B": "생성된 메트릭의 추이(trends)에서 식별한 잠재적 리스크를 포함시키도록 지침을 추가한다.",
      "C": "출력 형식에 대시보드 메트릭과 함께 이해 관계자를 위한 자연어 요약을 포함하도록 확장한다.",
      "D": "메트릭의 빠른 생성을 보장하기 위해 처리 속도를 제약 사항으로 강조한다."
    },
    "answer": "C",
    "points": 2
  },
  {
    "id": 35,
    "question": "35. 생성형 AI(Generative AI)를 활용한 테스트 제어(Test Control) 자동화에 대한 설명으로 가장 적절한 것은 \n무엇인가?",
    "options": {
      "A": "변경 사항이나 새로운 리스크 요소에 따라 테스트 케이스의 우선순위를 자동으로 재조정한 후 \n테스트를 실행하고, 이 결과를 기반으로 새로운 기능을 개발한다.",
      "B": "변경 사항이나 새로운 리스크 요소에 따라 테스트 케이스의 우선순위를 자동으로 재조정하고, \n자원을 효율적으로 분배한다.",
      "C": "변경 사항이나 새로운 리스크 요소에 따라 테스트 케이스의 우선순위를 자동으로 재조정하되, \n안정성 유지를 위해 테스트 계획을 변경하지 않고 기존 일정대로 테스트를 진행한다.",
      "D": "변경 사항이나 새로운 리스크 요소에 따라 테스트 케이스의 우선순위를 자동으로 재조정하되, \n테스트 실행 자동화를 통해 모든 테스트 케이스를 동일한 빈도로 실행한다."
    },
    "answer": "B",
    "points": 1
  },
  {
    "id": 36,
    "question": "36. 전자상거래 기업 A사는 연말 대규모 할인행사를 준비하고 있다. 예상되는 높은 트래픽으로 인해 시스템 \n부하와 성능 이슈에 대한 우려가 있다. 테스트 팀은 생성형 AI를 활용하여 테스트 모니터링 및 제어를 \n통해 이슈를 사전에 파악하고자 한다. \n생성형 AI를 활용하여 테스트 제어 자동화를 수행하기 위해 테스트 팀이 취할 수 있는 가장 효과적인 \n방법은 무엇인가?",
    "options": {
      "A": "기존의 테스트 계획을 변경하지 않고 그대로 진행하여 안정성을 유지한다.",
      "B": "모든 테스트 케이스를 동일한 빈도로 실행하여 커버리지를 최대화한다.",
      "C": "할인행사가 끝난 후 성능 이슈를 분석하여 다음 이벤트에 대비한다.",
      "D": "생성형 AI를 통해 실시간으로 서버 자원 사용률을 모니터링하고, 필요에 따라 테스트 우선순위를 \n재조정하며, 자원을 효율적으로 배분한다."
    },
    "answer": "D",
    "points": 2
  },
  {
    "id": 37,
    "question": "37. 생성형 AI를 활용해 헬스케어 애플리케이션을 테스팅하고 있다. 생성형 AI 모델은 다음과 같은 기능을 \n수행한다. \n환자 데이터 관리에 대한 테스트 케이스 생성 \nAPI 상호작용을 위한 테스트 스크립트 생성 \n엣지 케이스를 다루기 위한 합성 테스트 데이터 생성 \n다음 중 생성형 AI 모델의 성능을 효과적으로 평가하고 프롬프트를 개선하기 위해, 가장 적절한 평가 \n메트릭과 조치를 설명하고 있는 것은?",
    "options": {
      "A": "테스트 케이스의 다양성(diversity)을 평가해 다양한 입력 시나리오를 확보하고, 실행 \n성공률(Execution Success Rate)을 통해 API 테스트 스크립트의 기능을 검증한다.",
      "B": "정확성(accuracy)과 완전성(completeness) 메트릭을 활용해 테스트 케이스가 헬스케어 요구사항을 \n충족하는지 검증하고, AI 생성 스크립트와 수동 테스트 간의 실행 시간 효율성을 비교한다.",
      "C": "정밀도(precision)를 활용해 생성된 테스트 데이터가 헬스케어 규정을 준수하는지 검토하고, 맥락 \n적합성(contextual fit) 및 실행 성공률을 통해 테스트 스크립트의 적합성과 사용성을 평가한다.",
      "D": "모든 출력에 대해 적절성(relevance)과 맥락 적합성을 우선시하여 도메인 요구사항과의 일관성을 \n유지하고, 엣지 케이스 커버리지 확장을 위해 다양성(diversity) 메트릭을 포함한다."
    },
    "answer": "A",
    "points": 1
  },
  {
    "id": 38,
    "question": "38. 생성형 AI(Generative AI)가 테스트 케이스를 생성하는 데 소요된 시간과 사람이 동등한 테스트를 \n수동으로 작성하는 데 걸리는 시간을 비교하여 평가하는 지표는 무엇인가?",
    "options": {
      "A": "정확성 및 완전성(Accuracy and Completeness)",
      "B": "실행 성공률(Execution Success Rate)",
      "C": "시간 효율성(Time Efficiency)",
      "D": "정밀도(Precision)"
    },
    "answer": "C",
    "points": 1
  },
  {
    "id": 39,
    "question": "39. 은행 애플리케이션의 사용자 로그인 기능에 대한 테스트 케이스 생성 프롬프트를 최적화해야 한다. \n초기 프롬프트를 사용한 결과, \"잘못된 비밀번호 입력\"이나 \"계정 잠김\"과 같은 시나리오가 누락된 \n불완전한 테스트 케이스가 생성되었다. \n다음 중 반복적인 프롬프트 개선(Iterative Refinement) 방법을 사용해, 높은 품질과 맥락적으로 적절한 \n테스트 케이스를 생성할 수 있도록 해주는 가장 적절한 접근 방식은 무엇인가?",
    "options": {
      "A": "초기 프롬프트를 기반으로 A/B 테스팅을 수행해 다른 표현 방식을 비교하고, 오류 분석을 활용해 \n\"잘못된 비밀번호\" 등의 엣지 케이스를 반영하도록 프롬프트를 수정한다.",
      "B": "사용자 피드백을 기반으로 초기 프롬프트를 조정하고, 전체 구조의 변경 없이 예제를 추가해 \n불완전한 테스트 케이스 문제를 해결한다.",
      "C": "로그인 시나리오에 대한 세부 정보를 점진적으로 추가하면서 프롬프트를 개선하고, 최적의 표현 \n방식을 찾기 위해 A/B 테스팅을 수행해 더 짧은 프롬프트로 테스트한다.",
      "D": "오류 분석을 통해 누락된 시나리오를 식별하는 데 집중하고, A/B 테스팅이나 사용자 피드백을 \n활용하지 않고 최소한의 시간으로 프롬프트를 수정한다."
    },
    "answer": "A",
    "points": 1
  },
  {
    "id": 40,
    "question": "40. 생성형 AI(Generative AI)의 결과물을 실제 테스팅 요구사항에 더 부합하도록 하기 위해 사용자 피드백 \n통합(Incorporating User Feedback) 방법을 활용하려고 한다.  \n가장 적절한 활동은 무엇인가?",
    "options": {
      "A": "AI가 생성한 출력물을 수정하지 않고 그대로 사용한다.",
      "B": "생성된 출력물의 유용성과 명확성에 대한 피드백을 QA 엔지니어 또는 테스터로부터 수집하여 \n프롬프트를 개선한다.",
      "C": "프롬프트 길이를 줄여서 간결한 응답을 유도한다.",
      "D": "오류 분석을 통해 부정확성을 발견하고 프롬프트를 수정한다."
    },
    "answer": "B",
    "points": 1
  }
]
